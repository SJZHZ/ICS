0
工具：
	objdump：二进制代码反汇编为汇编
	十六进制编辑器：修改二进制代码
	gdb：调试

本地化：
	修改验证代码：
		找到验证函数位置，在运行验证函数时直接返回
		找到校验码赋值代码，把值修改了



1：
	一个字符串
	两个寄存器的寻址比较
	根据寄存器的地址访问字符串的值
2：
	六个数字
	循环给出数列的前六项
3：
	两个数字
	根据第一个参数来决定跳转行数
	跳转行数确定结果
4：
	两个数字，反过来装的
	递归乘法
	具体乘以多少可以不必计算，直接调试到函数结尾，看返回值
5：
	四个字母
	四个字母的ASCII码取后3位（and 7），转化成四个整数
	四个整数对应数组的下标，给出四个数组元素
	四个数组元素要乘出32
6：
	六个数字
	先处理输入：互不相同、1到6、每个都换算成7-x
	六个数字对应链表的六个元素
		链表的地址是相对地址
			可能是由于机器原因或调试工具原因，【代码地址】和【堆的地址】和【在文件中标注的位置】并不一样，有一个偏移量。
		好在前几个节点是相邻的，可以作差给算出相对位置，用相对位置+节点绝对地址访问链表
	使用冒泡排序，给出排序后的原顺序
	不必研究如何排序，只需要看出来是不断重复的比较和交换即可
	然后猜几次（升序、降序）